# 微服务与 NSQ

## 使用 NSQ 进行解耦

微服务是各个服务之间不能有直接的耦合。如果有直接的耦合，进行直接调用，则相当于一个整体的大钢板，无法拆。所以为了做到微服务，需要把所有的小组件全部拆开，然后通过 NSQ 通信。他可以发一条信息，另外一个 App 异步收到这个消息后，处理消息，整个流程只和消息有关，和任何接口无关，包括导入到搜索系统、离线系统、spark、跟踪系统，全部通过这个技术组件去做。  

Refer: [有赞-NSQ重塑之路](https://github.com/gopherchina/conference/blob/master/2017/1.5%20NSQ-%E9%87%8D%E5%A1%91%E4%B9%8B%E8%B7%AF.pdf)

## 在哪些情况下可能会发生重试

因为各种原因，消息可以被投递多次（客户端超时，连接失效，重新排队，等等）。由客户端负责操作。

## 为什么不能用 `nsqlookupd` 来查询生产的内容给谁?

https://doc.yonyoucloud.com/doc/wiki/project/nsq-guide/faq.html

NSQ 提升了**消费端**的发现模型，减轻了前期的配置负载（需要告诉所有消费者去那里找他们要的内容）。

然而，它并没有提供任何方法来解决发布端将内容发布给谁。这是鸡和蛋的问题，在发布前并不存在内容。

通过使用 `nsqd` ，你可以避开这个问题（你的服务只是简单的将内容发布给本地的 `nsqd`），并且允许 NSQ 实时发现系统正常运行。

## 话题和 channel

单个 `nsqd` 实例被设计成可以同时处理多个数据流。流被称为“话题”和话题有 1 个或多个“通道”。**每个通道都接收到一个话题中所有消息的拷贝**。在实践中，一个通道映射到下行服务消费一个话题.

话题和通道都没有预先配置。话题由第一次发布消息到命名的话题或第一次通过订阅一个命名话题来创建。通道被第一次订阅到指定的通道创建。

**总之，消息从话题->通道是多路传送的（每个通道接收的所有该话题消息的副本），即使均匀分布在通道->消费者之间（每个消费者收到该通道的消息的一部分）。**

还是原来的问题, channel 里是 topic 的副本被重复存了很多分, 但是 topic 与  topic 之间是独立的 !!!

## nsqlookupd

**NSQ** 还包括一个辅助应用程序，`nsqlookupd`，它提供了一个目录服务，消费者可以查找到提供他们感兴趣订阅话题的 `nsqd` 地址 。在配置方面，把消费者与生产者解耦开（它们都分别只需要知道哪里去连接 `nsqlookupd` 的共同实例，而不是对方），降低复杂性和维护。

在更底的层面，每个 `nsqd` 有一个与 `nsqlookupd` 的长期 TCP 连接，定期推动其状态。这个数据被 `nsqlookupd` 用于给消费者通知 `nsqd` 地址。对于消费者来说，一个暴露的 HTTP `/lookup` 接口用于轮询。

## NSQ 的特性

- 消息默认不持久化，可以配置成持久化模式。nsq采用的方式时内存+硬盘的模式，当内存到达一定程度时就会将数据持久化到硬盘。
  - 如果将`--mem-queue-size`设置为0，所有的消息将会存储到磁盘。
  - 服务器重启时也会将当时在内存中的消息持久化。
- 每条消息至少传递一次。
- 消息不保证有序。

## 设计特点

+ NSQ 是把消息推给客户端

  + 客户端决定要处理的消息: 这是客户端控制流量的一种状态

  